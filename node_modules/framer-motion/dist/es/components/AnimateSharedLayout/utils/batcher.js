import { __spreadArray, __read } from 'tslib';
import { flushSync } from 'framesync';
import { collectProjectingAncestors, updateLayoutMeasurement } from '../../../render/dom/projection/utils.js';
import { batchLayout, flushLayout } from '../../../render/dom/utils/batch-layout.js';
import { compareByDepth } from '../../../render/utils/compare-by-depth.js';
import { Presence } from '../types.js';

/**
 * Default handlers for batching VisualElements
 */
var defaultHandler = {
    layoutReady: function (child) { return child.notifyLayoutReady(); },
};
/**
 * Create a batcher to process VisualElements
 */
function createBatcher() {
    var queue = new Set();
    return {
        add: function (child) { return queue.add(child); },
        flush: function (_a) {
            var _b = _a === void 0 ? defaultHandler : _a, layoutReady = _b.layoutReady, parent = _b.parent;
            batchLayout(function (read, write) {
                if (!queue.size)
                    return;
                var order = Array.from(queue).sort(compareByDepth);
                var ancestors = [];
                if (parent) {
                    ancestors = collectProjectingAncestors(parent);
                }
                else {
                    // Find the ancestors for each top-level element in the queue
                    order.forEach(function (element) { return ancestors.push.apply(ancestors, __spreadArray([], __read(element.path))); });
                    ancestors = Array.from(new Set(ancestors)).filter(function (element) { return !queue.has(element); });
                }
                var allElements = __spreadArray(__spreadArray([], __read(ancestors)), __read(order));
                write(function () {
                    allElements.forEach(function (element) {
                        element.resetTransform();
                    });
                });
                read(function () {
                    ancestors.forEach(function (element) {
                        // !element.getLayoutState().isHydrated &&
                        return updateLayoutMeasurement(element);
                    });
                    order.forEach(function (element) {
                        updateLayoutMeasurement(element);
                    });
                });
                write(function () {
                    ancestors.forEach(function (element) {
                        element.restoreTransform();
                    });
                    order.forEach(layoutReady);
                });
                read(function () {
                    /**
                     * After all children have started animating, ensure any Entering components are set to Present.
                     * If we add deferred animations (set up all animations and then start them in two loops) this
                     * could be moved to the start loop. But it needs to happen after all the animations configs
                     * are generated in AnimateSharedLayout as this relies on presence data
                     */
                    order.forEach(function (child) {
                        if (child.isPresent)
                            child.presence = Presence.Present;
                    });
                });
                write(function () {
                    /**
                     * Starting these animations will have queued jobs on the frame loop. In some situations,
                     * like when removing an element, these will be processed too late after the DOM is manipulated,
                     * leaving a flash of incorrectly-projected content. By manually flushing these jobs
                     * we ensure there's no flash.
                     */
                    flushSync.preRender();
                    flushSync.render();
                    queue.clear();
                });
            });
            // TODO: Need to find a layout-synchronous way of flushing this
            flushLayout();
        },
    };
}

export { createBatcher };
