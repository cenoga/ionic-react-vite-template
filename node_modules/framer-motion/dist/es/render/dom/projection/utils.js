import { __assign } from 'tslib';
import { getFrameData } from 'framesync';
import { calcRelativeOffset } from '../../../motion/features/layout/utils.js';
import { eachAxis } from '../../../utils/each-axis.js';
import { copyAxisBox } from '../../../utils/geometry/index.js';
import { applyBoxTransforms } from '../../../utils/geometry/delta-apply.js';
import { compareByDepth } from '../../utils/compare-by-depth.js';

function isProjecting(visualElement) {
    var isEnabled = visualElement.projection.isEnabled;
    return (isEnabled ||
        visualElement.shouldResetTransform() ||
        visualElement.getProps()._applyTransforms);
}
function collectProjectingAncestors(visualElement, ancestors) {
    if (ancestors === void 0) { ancestors = []; }
    var parent = visualElement.parent;
    if (parent)
        collectProjectingAncestors(parent, ancestors);
    if (isProjecting(visualElement))
        ancestors.push(visualElement);
    return ancestors;
}
function collectProjectingChildren(visualElement) {
    var children = [];
    var addChild = function (child) {
        if (isProjecting(child))
            children.push(child);
        child.children.forEach(addChild);
    };
    visualElement.children.forEach(addChild);
    return children.sort(compareByDepth);
}
/**
 * Update the layoutState by measuring the DOM layout. This
 * should be called after resetting any layout-affecting transforms.
 */
function updateLayoutMeasurement(visualElement
// rebase = true
) {
    if (visualElement.shouldResetTransform())
        return;
    var layoutState = visualElement.getLayoutState();
    visualElement.notifyBeforeLayoutMeasure(layoutState.layout);
    layoutState.isHydrated = true;
    layoutState.layout = visualElement.measureViewportBox();
    layoutState.layoutCorrected = copyAxisBox(layoutState.layout);
    var snapshot = visualElement.snapshot;
    visualElement.notifyLayoutMeasure(layoutState.layout, snapshot ? snapshot.viewportBox : layoutState.layout);
    if (!visualElement.isProjectionReady()) {
        visualElement.rebaseProjectionTarget();
        // let isRelative = false
        var projectionParent = visualElement.getProjectionParent();
        if (projectionParent) {
            var parentLayout = projectionParent.getLayoutState();
            if (parentLayout && parentLayout.isHydrated) {
                var nextParentLayout_1 = copyAxisBox(parentLayout.layout);
                visualElement.path.forEach(function (node) {
                    if (node.getProps()._applyTransforms) {
                        applyBoxTransforms(nextParentLayout_1, nextParentLayout_1, node.getLatestValues());
                    }
                    var target = calcRelativeOffset(nextParentLayout_1, layoutState.layout);
                    eachAxis(function (axis) {
                        return visualElement.setProjectionTargetAxis(axis, target[axis].min, target[axis].max, true);
                    });
                    // isRelative = true
                });
            }
        }
    }
    // console.log("measuring layout", visualElement.getInstance().id)
    // TODO: Rebase to layout as transformed by parent
    // rebase && sync.update(() => visualElement.rebaseProjectionTarget())
}
/**
 * Record the viewport box as it was before an expected mutation/re-render
 */
function snapshotViewportBox(visualElement, rebase) {
    if (rebase === void 0) { rebase = true; }
    if (visualElement.shouldResetTransform())
        return;
    visualElement.snapshot = {
        taken: getFrameData().timestamp,
        transform: __assign({}, visualElement.getLatestValues()),
        viewportBox: visualElement.measureViewportBox(visualElement.getProps()._applyTransforms ? true : false),
    };
    /**
     * Update targetBox to match the snapshot. This is just to ensure
     * that targetBox is affected by scroll in the same way as the measured box
     */
    rebase &&
        visualElement.rebaseProjectionTarget(false, visualElement.snapshot.viewportBox);
}

export { collectProjectingAncestors, collectProjectingChildren, snapshotViewportBox, updateLayoutMeasurement };
