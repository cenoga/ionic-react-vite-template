import { __extends, __rest, __assign, __read } from 'tslib';
import * as React from 'react';
import { eachAxis } from '../../../utils/each-axis.js';
import { startAnimation, getValueTransition } from '../../../animation/utils/transitions.js';
import { checkIfParentHasChanged, calcRelativeOffset, tweenAxis } from './utils.js';
import { VisibilityAction } from '../../../components/AnimateSharedLayout/types.js';
import { usePresence } from '../../../components/AnimatePresence/use-presence.js';
import { axisBox, copyAxisBox } from '../../../utils/geometry/index.js';
import { addScaleCorrection } from '../../../render/dom/projection/scale-correction.js';
import { defaultScaleCorrectors } from '../../../render/dom/projection/default-scale-correctors.js';
import { removeBoxTransforms, applyBoxTransforms } from '../../../utils/geometry/delta-apply.js';
import { getFrameData } from 'framesync';

var progressTarget = 1000;
var Animate = /** @class */ (function (_super) {
    __extends(Animate, _super);
    function Animate() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * A mutable object that tracks the target viewport box
         * for the current animation frame.
         */
        _this.frameTarget = axisBox();
        /**
         * The current animation target, we use this to check whether to start
         * a new animation or continue the existing one.
         */
        _this.currentAnimationTarget = axisBox();
        /**
         * Track whether we're animating this axis.
         */
        _this.isAnimating = {
            x: false,
            y: false,
        };
        _this.stopAxisAnimation = {
            x: undefined,
            y: undefined,
        };
        _this.isAnimatingTree = false;
        _this.animate = function (target, origin, _a) {
            var _b, _c;
            if (_a === void 0) { _a = {}; }
            var originBox = _a.originBox, targetBox = _a.targetBox, visibilityAction = _a.visibilityAction, shouldStackAnimate = _a.shouldStackAnimate, onComplete = _a.onComplete, prevParent = _a.prevParent, config = __rest(_a, ["originBox", "targetBox", "visibilityAction", "shouldStackAnimate", "onComplete", "prevParent"]);
            var _d = _this.props, visualElement = _d.visualElement, layout = _d.layout;
            /**
             * Early return if we've been instructed not to animate this render.
             */
            if (shouldStackAnimate === false) {
                _this.isAnimatingTree = false;
                return _this.safeToRemove();
            }
            /**
             * Prioritise tree animations
             */
            if (_this.isAnimatingTree && shouldStackAnimate !== true) {
                return;
            }
            else if (shouldStackAnimate) {
                _this.isAnimatingTree = true;
            }
            /**
             * Allow the measured origin (prev bounding box) and target (actual layout) to be
             * overridden by the provided config.
             */
            origin = originBox || origin;
            target = targetBox || target;
            origin = copyAxisBox(origin);
            target = copyAxisBox(target);
            if (visualElement.getProps()._applyTransforms &&
                ((_b = visualElement.snapshot) === null || _b === void 0 ? void 0 : _b.transform)) {
                removeBoxTransforms(origin, (_c = visualElement.snapshot) === null || _c === void 0 ? void 0 : _c.transform);
            }
            visualElement.path.forEach(function (node) {
                if (node.getProps()._applyTransforms) {
                    applyBoxTransforms(target, target, node.getLatestValues());
                }
            });
            /**
             * If this element has a projecting parent, there's an opportunity to animate
             * it relatively to that parent rather than relatively to the viewport. This
             * allows us to add orchestrated animations.
             */
            var isRelative = false;
            var projectionParent = visualElement.getProjectionParent();
            var parentLayout;
            var convertTargetToRelative = function () {
                if (!parentLayout ||
                    !parentLayout.isHydrated ||
                    !projectionParent ||
                    !projectionParent.isProjectionReady())
                    return false;
                var nextParentLayout = copyAxisBox(parentLayout.layout);
                visualElement.path.forEach(function (node) {
                    if (node.getProps()._applyTransforms) {
                        applyBoxTransforms(nextParentLayout, nextParentLayout, node.getLatestValues());
                    }
                });
                target = calcRelativeOffset(nextParentLayout, target);
                return true;
            };
            if (projectionParent) {
                var parentSnapshot = projectionParent.snapshot;
                parentLayout = projectionParent.getLayoutState();
                /**
                 * If we're being provided a previous parent VisualElement by AnimateSharedLayout
                 *
                 * TODO: I suspect if we have a target or origin and there's no corresponding layout
                 * or snapshot we want to disable relative animation, but that is for a subsequent pass
                 * once a bug is isolated.
                 */
                if (prevParent) {
                    /**
                     * If we've been provided an explicit target box it means we're animating back
                     * to this previous parent. So we can make a relative box by comparing to the previous
                     * parent's layout
                     */
                    if (targetBox) {
                        projectionParent = prevParent;
                        parentLayout = prevParent.getLayoutState();
                    }
                    /**
                     * Likewise if we've been provided an explicit origin box it means we're
                     * animating out from a different element. So we should figure out where that was
                     * on screen relative to the new parent element.
                     */
                    if (originBox &&
                        !checkIfParentHasChanged(prevParent, projectionParent)) {
                        projectionParent = prevParent;
                        parentSnapshot = prevParent.snapshot;
                    }
                }
                if (projectionParent.isProjectionReady()) {
                    /**
                     * If the snapshot is out
                     */
                    if (!parentSnapshot ||
                        parentSnapshot.taken !== getFrameData().timestamp) {
                        parentSnapshot = {
                            taken: 0,
                            viewportBox: copyAxisBox(projectionParent.projection.target),
                            transform: projectionParent.getLatestValues(),
                        };
                    }
                    if (isProvidedCorrectDataForRelativeSharedLayout(prevParent, originBox, targetBox)) {
                        isRelative = true;
                        var prevParentViewportBox = copyAxisBox(parentSnapshot.viewportBox);
                        // applyBoxTransforms(
                        //     prevParentViewportBox,
                        //     parentSnapshot.viewportBox,
                        //     parentSnapshot.transform
                        // )
                        // if (visualElement.getInstance().id === "a-square") {
                        //     console.log("BEFORE RELATIVE", {
                        //         origin: copyAxisBox(origin),
                        //         target: copyAxisBox(target),
                        //         prevParentBox: copyAxisBox(prevParentViewportBox),
                        //         parentLayout: copyAxisBox(nextParentLayout),
                        //         parentSnapshot: parentSnapshot,
                        //     })
                        // }
                        origin = calcRelativeOffset(prevParentViewportBox, origin);
                        convertTargetToRelative();
                        // if (visualElement.getInstance().id === "a-square") {
                        //     console.log("AFTER RELATIVE", {
                        //         origin: copyAxisBox(origin),
                        //         target: copyAxisBox(target),
                        //     })
                        // }
                    }
                }
            }
            var boxHasMoved = hasMoved(origin, target);
            var animations = eachAxis(function (axis) {
                /**
                 * If layout is set to "position", we can resize the origin box based on the target
                 * box and only animate its position.
                 */
                if (layout === "position") {
                    var targetLength = target[axis].max - target[axis].min;
                    origin[axis].max = origin[axis].min + targetLength;
                }
                if (visualElement.projection.isTargetLocked) {
                    return;
                }
                else if (visibilityAction !== undefined) {
                    visualElement.setVisibility(visibilityAction === VisibilityAction.Show);
                }
                else if (boxHasMoved) {
                    // If the box has moved, animate between it's current visual state and its
                    // final state
                    return _this.animateAxis(axis, target[axis], origin[axis], __assign(__assign({}, config), { isRelative: isRelative }));
                }
                else {
                    // this.stopAxisAnimation[axis]?.()
                    if (!isRelative) {
                        isRelative = convertTargetToRelative();
                    }
                    // if (visualElement.getInstance().id === "child") {
                    //     console.log(
                    //         isRelative,
                    //         boxHasMoved,
                    //         origin.x.min,
                    //         target.x.min
                    //     )
                    // }
                    // If the box has remained in the same place, immediately set the axis target
                    // to the final desired state
                    return visualElement.setProjectionTargetAxis(axis, target[axis].min, target[axis].max, isRelative);
                }
            });
            // Force a render to ensure there's no flash of uncorrected bounding box.
            visualElement.syncRender();
            /**
             * If this visualElement isn't present (ie it's been removed from the tree by the user but
             * kept in by the tree by AnimatePresence) then call safeToRemove when all axis animations
             * have successfully finished.
             */
            return Promise.all(animations).then(function () {
                _this.isAnimatingTree = false;
                onComplete && onComplete();
                visualElement.notifyLayoutAnimationComplete();
            });
        };
        return _this;
    }
    Animate.prototype.componentDidMount = function () {
        var _this = this;
        var visualElement = this.props.visualElement;
        visualElement.animateMotionValue = startAnimation;
        visualElement.enableLayoutProjection();
        this.unsubLayoutReady = visualElement.onLayoutUpdate(this.animate);
        visualElement.layoutSafeToRemove = function () { return _this.safeToRemove(); };
        addScaleCorrection(defaultScaleCorrectors);
    };
    Animate.prototype.componentWillUnmount = function () {
        var _this = this;
        this.unsubLayoutReady();
        eachAxis(function (axis) { var _a, _b; return (_b = (_a = _this.stopAxisAnimation)[axis]) === null || _b === void 0 ? void 0 : _b.call(_a); });
    };
    /**
     * TODO: This manually performs animations on the visualElement's layout progress
     * values. It'd be preferable to amend the startLayoutAxisAnimation
     * API to accept more custom animations like this.
     */
    Animate.prototype.animateAxis = function (axis, target, origin, _a) {
        var _this = this;
        var _b, _c;
        var _d = _a === void 0 ? {} : _a, transition = _d.transition, isRelative = _d.isRelative;
        /**
         * If we're not animating to a new target, don't run this animation
         */
        if (this.isAnimating[axis] &&
            axisIsEqual(target, this.currentAnimationTarget[axis])) {
            return;
        }
        (_c = (_b = this.stopAxisAnimation)[axis]) === null || _c === void 0 ? void 0 : _c.call(_b);
        this.isAnimating[axis] = true;
        var visualElement = this.props.visualElement;
        var frameTarget = this.frameTarget[axis];
        var layoutProgress = visualElement.getProjectionAnimationProgress()[axis];
        /**
         * Set layout progress back to 0. We set it twice to hard-reset any velocity that might
         * be re-incoporated into a subsequent spring animation.
         */
        layoutProgress.clearListeners();
        layoutProgress.set(0);
        layoutProgress.set(0);
        /**
         * Create an animation function to run once per frame. This will tween the visual bounding box from
         * origin to target using the latest progress value.
         */
        var frame = function () {
            // Convert the latest layoutProgress, which is a value from 0-1000, into a 0-1 progress
            var p = layoutProgress.get() / progressTarget;
            // Tween the axis and update the visualElement with the latest values
            tweenAxis(frameTarget, origin, target, p);
            visualElement.setProjectionTargetAxis(axis, frameTarget.min, frameTarget.max, isRelative);
        };
        // Synchronously run a frame to ensure there's no flash of the uncorrected bounding box.
        frame();
        // Create a function to stop animation on this specific axis
        var unsubscribeProgress = layoutProgress.onChange(frame);
        this.stopAxisAnimation[axis] = function () {
            _this.isAnimating[axis] = false;
            layoutProgress.stop();
            unsubscribeProgress();
        };
        this.currentAnimationTarget[axis] = target;
        var layoutTransition = transition ||
            visualElement.getDefaultTransition() ||
            defaultLayoutTransition;
        // Start the animation on this axis
        var animation = startAnimation(axis === "x" ? "layoutX" : "layoutY", layoutProgress, progressTarget, layoutTransition && getValueTransition(layoutTransition, "layout")).then(this.stopAxisAnimation[axis]);
        return animation;
    };
    Animate.prototype.safeToRemove = function () {
        var _a, _b;
        (_b = (_a = this.props).safeToRemove) === null || _b === void 0 ? void 0 : _b.call(_a);
    };
    Animate.prototype.render = function () {
        return null;
    };
    return Animate;
}(React.Component));
function AnimateLayoutContextProvider(props) {
    var _a = __read(usePresence(), 2), safeToRemove = _a[1];
    return React.createElement(Animate, __assign({}, props, { safeToRemove: safeToRemove }));
}
function hasMoved(a, b) {
    return (!isZeroBox(a) &&
        !isZeroBox(b) &&
        (!axisIsEqual(a.x, b.x) || !axisIsEqual(a.y, b.y)));
}
var zeroAxis = { min: 0, max: 0 };
function isZeroBox(a) {
    return axisIsEqual(a.x, zeroAxis) && axisIsEqual(a.y, zeroAxis);
}
function axisIsEqual(a, b) {
    return a.min === b.min && a.max === b.max;
}
var defaultLayoutTransition = {
    duration: 0.45,
    ease: [0.4, 0, 0.1, 1],
};
function isProvidedCorrectDataForRelativeSharedLayout(prevParent, originBox, targetBox) {
    return prevParent || (!prevParent && !(originBox || targetBox));
}

export { AnimateLayoutContextProvider };
